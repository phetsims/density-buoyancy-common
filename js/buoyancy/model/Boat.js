// Copyright 2019, University of Colorado Boulder

/**
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( require => {
  'use strict';

  // modules
  const Cubic = require( 'KITE/segments/Cubic' );
  const densityBuoyancyCommon = require( 'DENSITY_BUOYANCY_COMMON/densityBuoyancyCommon' );
  const InterpolatedProperty = require( 'DENSITY_BUOYANCY_COMMON/common/model/InterpolatedProperty' );
  const Line = require( 'KITE/segments/Line' );
  const Mass = require( 'DENSITY_BUOYANCY_COMMON/common/model/Mass' );
  const merge = require( 'PHET_CORE/merge' );
  const NumberProperty = require( 'AXON/NumberProperty' );
  const Shape = require( 'KITE/Shape' );
  const Util = require( 'DOT/Util' );
  const Vector2 = require( 'DOT/Vector2' );
  const Vector3 = require( 'DOT/Vector3' );

  // constants
  const OUTSIDE = 3;
  const BOAT_HEIGHT = 50;

  // NOTE: machine generated by copy( phet.densityBuoyancyCommon.Boat.computeBoatData() );
  // If any parameters about the bottle shape changes, this should be recomputed.
  const ONE_LITER_SCALE_MULTIPLIER = 0.0012334765488263802;
  const DESIGN_CENTROID = new Vector3( 133.563381778044, -30.51940700558119, 0 );
  // const DESIGN_DISPLACED_VOLUME = 532852.8697157894;
  // const DESIGN_ACTUAL_VOLUME = 81410.06188763793;

  class Boat extends Mass {
    /**
     * @param {Engine} engine
     * @param {Bounds3} size
     * @param {number} thickness
     * @param {Object} config
     */
    constructor( engine, size, thickness, config ) {

      // TODO
      const boatVertices = [];
      const volume = 0;

      config = merge( {
        body: engine.createFromVertices( boatVertices ),
        shape: Shape.polygon( boatVertices ),
        volume: volume,
        canRotate: false

        // material
      }, config );

      assert && assert( !config.canRotate );

      super( engine, config );

      // @public {Property.<number>}
      this.liquidVolumeProperty = new NumberProperty( 0 );

      // @public {Property.<number>} - The y coordinate of the main liquid level in the boat (relative to interiorSize.minY)
      this.liquidYProperty = new InterpolatedProperty( 0, {
        interpolate: InterpolatedProperty.interpolateNumber
      } );
    }

    /**
     * Steps forward in time.
     * @public
     * @override
     *
     * @param {number} dt
     * @param {number} interpolationRatio
     */
    step( dt, interpolationRatio ) {
      super.step( dt, interpolationRatio );

      this.liquidYProperty.setRatio( interpolationRatio );
    }
    /**
     * Returns whether this is a boat (as more complicated handling is needed in this case).
     * @public
     * @override
     *
     * @returns {boolean}
     */
    isBoat() {
      return true;
    }

    updateStepInformation() {
      // TODO: see if we can extend cuboid
      this.engine.bodyGetStepMatrixTransform( this.body, this.stepMatrix );

      const xOffset = this.stepMatrix.m02();
      const yOffset = this.stepMatrix.m12();

      const TODO = 5;

      this.stepX = xOffset;
      this.stepBottom = yOffset + -TODO;
      this.stepTop = yOffset + TODO;
    }

    /**
     * If there is an intersection with the ray and this mass, the t-value (distance the ray would need to travel to
     * reach the intersection, e.g. ray.position + ray.distance * t === intersectionPoint) will be returned. Otherwise
     * if there is no intersection, null will be returned.
     * @public
     * @override
     *
     * @param {Ray3} ray
     * @param {boolean} isTouch
     * @returns {number|null}
     */
    intersect( ray, isTouch ) {
      // TODO

      return null;
    }

    /**
     * Returns the cumulative displaced volume of this object up to a given y level.
     * @public
     * @override
     *
     * Assumes step information was updated.
     *
     * @param {number} liquidLevel
     * @returns {number}
     */
    getDisplacedArea( liquidLevel ) {
      return 0; // TODO
    }

    /**
     * Returns the displaced volume of this object up to a given y level, assuming a y value for the given liquid level.
     * @public
     * @override
     *
     * Assumes step information was updated.
     *
     * @param {number} liquidLevel
     * @returns {number}
     */
    getDisplacedVolume( liquidLevel ) {
      return 0; // TODO
    }

    /**
     * TODO: doc. Uses liquid compensation
     * @public
     * @override
     *
     * @param {number} liquidLevel
     * @returns {number}
     */
    getDisplacedBuoyantVolume( liquidLevel ) {
      // TODO: yikes! Imagine boat with liquid with things floating in it. figure out.
      // TODO: NOPE NOPE NOPE NOPE NOPE NOPE NOPE this isn't right
      return 0; // TODO:
    }

    reset() {
      this.liquidVolumeProperty.reset();
      this.liquidYProperty.reset();

      super.reset();
    }

    static getHeightRatioFromDesignY( y ) {
      return Util.linear( -BOAT_HEIGHT, 0, 0, 1, y );
    }

    static getControlPoints( heightRatio, isInside ) {
      const v0 = new Vector2( 0, 0 );
      const v1 = new Vector2( 50, 50 );
      const v2 = new Vector2( 150, 50 );
      const v3 = new Vector2( 200, 40 );

      const ratio = Math.pow( heightRatio, 2 );
      const oppositeRatio = 1 - ratio;

      v0.x += 50 * oppositeRatio;
      v1.x += 60 * oppositeRatio;

      v1.y += -20 * oppositeRatio;
      v2.y += -15 * oppositeRatio;
      v3.y += -5 * oppositeRatio;

      if ( !isInside ) {
        v0.x += -( 1.4 + 0.5 * oppositeRatio ) * OUTSIDE;

        v1.x += -0.9 * OUTSIDE;
        v1.y += 0.9 * OUTSIDE;

        v2.y += OUTSIDE;

        v3.x += OUTSIDE;
        v3.y += ( 0.9 - 0.1 * ratio ) * OUTSIDE;
      }

      return [ v0, v1, v2, v3 ];
    }

    static getSegmentsFromControlPoints( points ) {
      const flip = p => p.componentTimes( new Vector2( 1, -1 ) );

      return [
        new Cubic( ...points ),
        new Line( points[ 3 ], flip( points[ 3 ] ) ),
        new Cubic( ...points.slice().reverse().map( flip ) )
      ];
    }

    static getAreaFromControlPoints( points ) {
      return Math.abs( _.sum( Boat.getSegmentsFromControlPoints( points ).map( segment => segment.getSignedAreaFragment() ) ) );
    }

    static getDiscretizationFromControlPoints( points, quantity ) {
      return _.flatten( Boat.getSegmentsFromControlPoints( points ).map( segment => {
        return (
          segment instanceof Line ? [ 0 ] : _.range( 0, quantity ).map( n => n / quantity )
        ).map( t => segment.positionAt( t ) );
      } ) );
    }

    /**
     * Meant for mapping a raw number-based array of x,y,z position data from the construction coordinates to model
     * coordinates.
     * @private
     *
     * @param {number} point
     * @param {number} index
     * @returns {number}
     */
    static positionArrayMap( point, index ) {
      const mod = index % 3;

      // x
      if ( mod === 0 ) {
        point -= DESIGN_CENTROID.x;
      }

      // y
      if ( mod === 1 ) {
        point -= DESIGN_CENTROID.y;
      }

      return point * ONE_LITER_SCALE_MULTIPLIER;
    }

    /**
     * Returns the model-coordinate main geometry for the bulk of the boat.
     * @public
     *
     * @returns {THREE.BufferGeometry}
     */
    static getPrimaryGeometry() {
      const positions = [];
      const normals = [];
      const uvs = [];

      const boatGeometry = new THREE.BufferGeometry();
      boatGeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( positions.map( Boat.positionArrayMap ) ), 3 ) );
      boatGeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( normals ), 3 ) );
      boatGeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( uvs ), 2 ) );
      return boatGeometry;
    }

    static computeBoatData( samples = 1000 ) {
      const desiredVolume = 0.001;

      const discretizationPoints = 1000;

      let externalAreaSum = 0;
      let areaSum = 0;
      let weightedCentroidSum = new Vector3( 0, 0, 0 );
      const sliceAreas = [];
      _.range( 0, samples ).forEach( i => {
        // unit area times the multiplier
        const y = i / ( samples - 1 ) * -BOAT_HEIGHT;
        const heightRatio = Boat.getHeightRatioFromDesignY( y );
        const externalControlPoints = Boat.getControlPoints( heightRatio, false );
        const internalControlPoints = Boat.getControlPoints( heightRatio, true );
        const externalArea = Boat.getAreaFromControlPoints( externalControlPoints );
        const internalArea = Boat.getAreaFromControlPoints( internalControlPoints );
        const externalCentroid = Util.centroidOfPolygon( Boat.getDiscretizationFromControlPoints( externalControlPoints, discretizationPoints ) );
        const internalCentroid = Util.centroidOfPolygon( Boat.getDiscretizationFromControlPoints( internalControlPoints, discretizationPoints ) );

        let area = externalArea;
        let weightedCentroid = externalCentroid.timesScalar( externalArea );

        if ( y > -BOAT_HEIGHT + OUTSIDE ) {
          area -= internalArea;
          weightedCentroid = weightedCentroid.minus( internalCentroid.timesScalar( internalArea ) );
        }

        sliceAreas.push( externalArea );
        externalAreaSum += externalArea;
        areaSum += area;
        weightedCentroidSum = weightedCentroidSum.plus( new Vector3( weightedCentroid.x, y * area, 0 ) );
      } );
      const displacedVolume = externalAreaSum / samples * BOAT_HEIGHT;
      const actualVolume = areaSum / samples * BOAT_HEIGHT;
      const oneLiterMultiplier = Math.pow( displacedVolume / desiredVolume, -1 / 3 );

      const centroid = weightedCentroidSum.timesScalar( 1 / areaSum );

      return `
  // NOTE: machine generated by copy( phet.densityBuoyancyCommon.Boat.computeBoatData() );
  // If any parameters about the bottle shape changes, this should be recomputed.
  const ONE_LITER_SCALE_MULTIPLIER = ${oneLiterMultiplier};
  const DESIGN_CENTROID = new Vector3( ${centroid.x}, ${centroid.y}, ${centroid.z} );
  const DESIGN_DISPLACED_VOLUME = ${displacedVolume};
  const DESIGN_ACTUAL_VOLUME = ${actualVolume};
`;
    }

    /**
     * Replaces the main page with a debug view of the bottle, for debugging various curves and properties.
     * @public
     */
    static getDebugCanvas() {
      const canvas = document.createElement( 'canvas' );
      const context = canvas.getContext( '2d' );

      const width = 800;
      const height = 400;

      const pixelRatio = window.devicePixelRatio || 1;
      canvas.width = width * pixelRatio;
      canvas.height = height * pixelRatio;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      context.scale( pixelRatio, pixelRatio );

      const scale = width / 210;

      const mapX = x => ( x + 5 ) * scale;
      const mapY = y => -y * scale + height / 2;

      const cubic = points => {
        context.moveTo( mapX( points[ 0 ].x ), mapY( points[ 0 ].y ) );
        context.bezierCurveTo(
          mapX( points[ 1 ].x ), mapY( points[ 1 ].y ),
          mapX( points[ 2 ].x ), mapY( points[ 2 ].y ),
          mapX( points[ 3 ].x ), mapY( points[ 3 ].y )
        );
        context.moveTo( mapX( points[ 0 ].x ), mapY( -points[ 0 ].y ) );
        context.bezierCurveTo(
          mapX( points[ 1 ].x ), mapY( -points[ 1 ].y ),
          mapX( points[ 2 ].x ), mapY( -points[ 2 ].y ),
          mapX( points[ 3 ].x ), mapY( -points[ 3 ].y )
        );
      };

      const boatProfile = points => {
        cubic( points );
        context.moveTo( mapX( points[ 3 ].x ), mapY( points[ 3 ].y ) );
        context.lineTo( mapX( points[ 3 ].x ), mapY( -points[ 3 ].y ) );
      };

      context.strokeStyle = 'red';
      context.beginPath();
      boatProfile( Boat.getControlPoints( 1, false ) );
      context.stroke();

      context.strokeStyle = 'blue';
      context.beginPath();
      boatProfile( Boat.getControlPoints( 1, true ) );
      context.stroke();

      context.strokeStyle = 'green';
      context.beginPath();
      boatProfile( Boat.getControlPoints( 0, false ) );
      context.stroke();

      context.strokeStyle = 'magenta';
      context.beginPath();
      boatProfile( Boat.getControlPoints( 0, true ) );
      context.stroke();

      while ( document.body.childNodes[ 0 ] ) {
        document.body.removeChild( document.body.childNodes[ 0 ] );
      }
      document.body.appendChild( canvas );
      document.body.style.background = 'white';

      return canvas;
    }
  }

  return densityBuoyancyCommon.register( 'Boat', Boat );
} );
